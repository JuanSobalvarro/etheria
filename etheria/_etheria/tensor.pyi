"""
Internal representation of a multi-dimensional array (tensor) that can reside on CPU or GPU.

This module provides the Tensor class with methods for data access, device management,
and basic arithmetic operations.
"""
from typing import Tuple, Union, List, Sequence


class Tensor:
    """
    Internal representation of a multi-dimensional array (tensor) that can reside on CPU or GPU.
    """

    requires_grad: bool

    # Constructors
    def __init__(
        self,
        data: Union[float, List[float], None] = None,
        shape: Union[Tuple[int, ...], List[int], None] = None,
        device_id: int = -1,
        requires_grad: bool = False
    ) -> None: ...

    # get sub tensor
    def get_subtensor(self, index: int) -> 'Tensor': ...
    def get_subtensor_multi(self, indices: Union[Tuple[int, ...], List[int]]) -> 'Tensor': ...

    # Flattened index access
    def get_flat(self, index: int) -> float: ...
    def set_flat(self, index: int, value: float) -> None: ...
    
    # Multi-index access
    def get_flat_multi(self, indices: Union[int, Tuple[int, ...], List[int]]) -> float: ...
    def set_flat_multi(self, indices: Union[int, Tuple[int, ...], List[int]], value: float) -> None: ...

    # Device management
    def move_to_gpu(self, device_id: int) -> None: ...
    def move_to_cpu(self) -> None: ...

    def current_device(self) -> int: ...

    # Shape and size
    def get_shape(self) -> Tuple[int, ...]: ...
    def size(self) -> int: ...
    def to_vector(self) -> List[float]: ...

    # Math operations (CPU only for now)
    def add(self, other: 'Tensor') -> 'Tensor': ...
    def add_scalar(self, scalar: float) -> 'Tensor': ...
    def subtract(self, other: 'Tensor') -> 'Tensor': ...
    def multiply(self, other: 'Tensor') -> 'Tensor': ...
    def scalar_multiply(self, scalar: float) -> 'Tensor': ...
    def outer_product(self, other: 'Tensor') -> 'Tensor': ...
    def dot_product(self, other: 'Tensor') -> 'Tensor': ...
    def transpose(self, axes: List[int]) -> 'Tensor': ...
    def contract(self, axes: List[Tuple[int, int]]) -> 'Tensor': ...

    def reshape(self, new_shape: Union[Tuple[int, ...], List[int]]) -> None: ...
